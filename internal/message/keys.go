package message

import (
	"crypto/ed25519"
	"crypto/rand"
	"crypto/sha256" // NEW: Added for Base64 encoding/decoding
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"strings"

	"golang.org/x/crypto/chacha20poly1305"
	"golang.org/x/crypto/curve25519"
	"golang.org/x/crypto/hkdf"
)

// MessageContact holds the public keys for a party.
type MessageContact struct {
	Endpoint      string
	EncryptionKey []byte // X25519 public key (binary)
	SignatureKey  []byte // Ed25519 public key (binary)
}

// PublicKeySet defines the structure for the JSON file containing public keys, as generated by msg-keygen.
type PublicKeySet struct {
	EncryptionKey string `json:"X25519_Pub"`  // X25519 Public Key (Base64)
	SignatureKey  string `json:"Ed25519_Pub"` // Ed25519 Public Key (Base64)
}

// PrivateKeySet defines the structure for the JSON file containing private keys.
// NOTE: We only store the X25519 Private Key and the Ed25519 Private Key.
// The X25519 public key is derived from the X25519 private key, and the
// Ed25519 public key is part of the Ed25519 private key structure (or derived
// from the private key seed).

type PrivateKeySet struct {
	DecryptionKey string `json:"X25519_Priv"`  // X25519 Private Key (Base64)
	SigningKey    string `json:"Ed25519_Priv"` // Ed25519 Private Key (Base64)
}

// LoadContactFromFile reads a public key JSON file, decodes the Base64 keys,
// and returns a MessageContact struct.
func LoadContactFromFile(filename string) (MessageContact, error) {
	var pubKeys PublicKeySet
	data, err := os.ReadFile(filename)
	if err != nil {
		return MessageContact{}, fmt.Errorf("failed to read file %s: %w", filename, err)
	}
	if err := json.Unmarshal(data, &pubKeys); err != nil {
		return MessageContact{}, fmt.Errorf("failed to parse JSON from %s: %w", filename, err)
	}

	xPub, err := base64.StdEncoding.DecodeString(pubKeys.EncryptionKey)
	if err != nil {
		return MessageContact{}, fmt.Errorf("failed to decode X25519 public key: %w", err)
	}
	edPub, err := base64.StdEncoding.DecodeString(pubKeys.SignatureKey)
	if err != nil {
		return MessageContact{}, fmt.Errorf("failed to decode Ed25519 public key: %w", err)
	}

	return MessageContact{
		EncryptionKey: xPub,
		SignatureKey:  edPub,
	}, nil
}

func LoadPrivateKeys(filename string, privKeys *PrivateKeySet) error {

	data, err := os.ReadFile(filename)
	if err != nil {
		return fmt.Errorf("failed to read file %s: %w", filename, err)
	}
	if err := json.Unmarshal(data, privKeys); err != nil {
		return fmt.Errorf("failed to parse JSON from %s: %w", filename, err)
	}
	return nil
}

// Ed25519PrivateKeyToCurve25519 converts an Ed25519 private key to an X25519 private key.
func Ed25519PrivateKeyToCurve25519(edPriv ed25519.PrivateKey) []byte {
	var curvePriv [32]byte
	copy(curvePriv[:], edPriv[:32])
	return curvePriv[:]
}

// DeriveX25519PublicKey calculates the X25519 public key from the Ed25519 private key.
func DeriveX25519PublicKey(edPriv ed25519.PrivateKey) ([]byte, error) {
	x25519Priv := Ed25519PrivateKeyToCurve25519(edPriv)
	x25519Pub, err := curve25519.X25519(x25519Priv, curve25519.Basepoint)
	if err != nil {
		return nil, err
	}
	return x25519Pub, nil
}

// keyDerivationFunction uses HKDF to derive a Key Encryption Key (KEK).
func keyDerivationFunction(sharedSecret []byte, keyLen int) ([]byte, error) {
	kekInfo := []byte("HPKE_KEK_Wrap")
	h := hkdf.New(sha256.New, sharedSecret, nil, kekInfo)
	key := make([]byte, keyLen)
	if _, err := h.Read(key); err != nil {
		return nil, fmt.Errorf("hkdf read failed: %w", err)
	}
	return key, nil
}

// keyWrap encrypts the symmetric key (chachaKey) using the DH shared secret's HKDF output (KEK).
func keyWrap(sharedSecret, chachaKey []byte) ([]byte, error) {
	kek, err := keyDerivationFunction(sharedSecret, 32)
	if err != nil {
		return nil, err
	}

	aead, err := chacha20poly1305.New(kek)
	if err != nil {
		return nil, fmt.Errorf("failed to create AEAD for key wrap: %w", err)
	}

	nonce := make([]byte, aead.NonceSize())
	wrappedKey := aead.Seal(nil, nonce, chachaKey, nil)
	return wrappedKey, nil
}

// keyUnwrap decrypts the symmetric key (chachaKey) using the DH shared secret's HKDF output (KEK).
func keyUnwrap(sharedSecret, wrappedKey []byte) ([]byte, error) {
	kek, err := keyDerivationFunction(sharedSecret, 32)
	if err != nil {
		return nil, err
	}

	aead, err := chacha20poly1305.New(kek)
	if err != nil {
		return nil, fmt.Errorf("failed to create AEAD for key unwrap: %w", err)
	}

	nonce := make([]byte, aead.NonceSize())

	chachaKey, err := aead.Open(nil, nonce, wrappedKey, nil)
	if err != nil {
		return nil, errors.New("key unwrap failed (invalid tag)")
	}
	return chachaKey, nil
}

// CreateNormalizedMessage generates a deterministic string from the message components for signing.
func CreateNormalizedMessage(msg EncryptedMessage) []byte {
	versionHex := fmt.Sprintf("%02x", msg.Version)
	wrappedKeysJoined := strings.Join(msg.WrappedKeys, "")

	senderKeys := append(msg.Sender.EncryptionKey, msg.Sender.SignatureKey...)
	senderKeysBase64 := base64.StdEncoding.EncodeToString(senderKeys)

	dataBase64 := msg.Data

	normalizedString := versionHex + wrappedKeysJoined + senderKeysBase64 + dataBase64

	return []byte(normalizedString)
}

// GenerateKeys generates a pair of Ed25519 public/private keys.
func GenerateKeys() (ed25519.PublicKey, ed25519.PrivateKey, error) {
	return ed25519.GenerateKey(rand.Reader)
}

func GenerateKeySets() (PublicKeySet, PrivateKeySet, error) {
	// 1. Generate core Ed25519 key pair
	edPub, edPriv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return PublicKeySet{}, PrivateKeySet{},
			fmt.Errorf("key generation error: failed to generate Ed25519 keys: %v", err)
	}

	// 2. Derive X25519 keys from the Ed25519 private key
	x25519Pub, err := DeriveX25519PublicKey(edPriv)
	if err != nil {
		return PublicKeySet{}, PrivateKeySet{},
			fmt.Errorf("key generation error: failed to derive X25519 public key: %v", err)
	}
	x25519Priv := Ed25519PrivateKeyToCurve25519(edPriv)

	// 3. Prepare structures for JSON output (Base64 encoded)

	// --- Public Keys ---
	pubKeys := PublicKeySet{
		EncryptionKey: base64.StdEncoding.EncodeToString(x25519Pub),
		SignatureKey:  base64.StdEncoding.EncodeToString(edPub),
	}

	// --- Private Keys ---
	privKeys := PrivateKeySet{
		DecryptionKey: base64.StdEncoding.EncodeToString(x25519Priv),
		SigningKey:    base64.StdEncoding.EncodeToString(edPriv),
	}

	return pubKeys, privKeys, nil
}
