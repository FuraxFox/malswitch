package aiq_message

import (
	"crypto/ed25519"
	"crypto/rand"
	"crypto/sha256" // NEW: Added for Base64 encoding/decoding
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"strings"

	"golang.org/x/crypto/chacha20poly1305"
	"golang.org/x/crypto/curve25519"
	"golang.org/x/crypto/hkdf"
)

// MessageContact holds the public keys for a party.
type MessageContact struct {
	Endpoint      string
	EncryptionKey []byte // X25519 public key (binary)
	SignatureKey  []byte // Ed25519 public key (binary)
}

// PublicKeySet defines the structure for the JSON file containing public keys, as generated by msg-keygen.
type PublicKeySet struct {
	EncryptionKey string `json:"X25519_Pub"`  // X25519 Public Key (Base64)
	SignatureKey  string `json:"Ed25519_Pub"` // Ed25519 Public Key (Base64)
}

// PrivateKeySet defines the structure for the JSON file containing private keys.
// NOTE: We only store the X25519 Private Key and the Ed25519 Private Key.
// The X25519 public key is derived from the X25519 private key, and the
// Ed25519 public key is part of the Ed25519 private key structure (or derived
// from the private key seed).
type PrivateKeySet struct {
	DecryptionKey []byte             // X25519 Private Key (Binary)
	SigningKey    ed25519.PrivateKey // Ed25519 Private Key (Binary)
}

// LoadContactFromFile reads a public key JSON file, decodes the Base64 keys,
// and returns a MessageContact struct.
func LoadContactFromFile(filename string) (MessageContact, error) {
	var pubKeys PublicKeySet
	data, err := os.ReadFile(filename)
	if err != nil {
		return MessageContact{}, fmt.Errorf("failed to read file %s: %w", filename, err)
	}
	if err := json.Unmarshal(data, &pubKeys); err != nil {
		return MessageContact{}, fmt.Errorf("failed to parse JSON from %s: %w", filename, err)
	}

	xPub, err := base64.StdEncoding.DecodeString(pubKeys.EncryptionKey)
	if err != nil {
		return MessageContact{}, fmt.Errorf("failed to decode X25519 public key: %w", err)
	}
	edPub, err := base64.StdEncoding.DecodeString(pubKeys.SignatureKey)
	if err != nil {
		return MessageContact{}, fmt.Errorf("failed to decode Ed25519 public key: %w", err)
	}

	return MessageContact{
		EncryptionKey: xPub,
		SignatureKey:  edPub,
	}, nil
}

// LoadPrivateKeys reads a private key JSON file, decodes the Base64 keys,
// and returns a PrivateKeySet struct containing binary keys.
func LoadPrivateKeys(filename string) (PrivateKeySet, error) {
	// Local struct to handle Base64 decoding from JSON
	type PrivateKeySetBase64 struct {
		DecryptionKey string `json:"X25519_Priv"`
		SigningKey    string `json:"Ed25519_Priv"`
	}

	var base64Keys PrivateKeySetBase64
	data, err := os.ReadFile(filename)
	if err != nil {
		return PrivateKeySet{}, fmt.Errorf("failed to read file %s: %w", filename, err)
	}
	if err := json.Unmarshal(data, &base64Keys); err != nil {
		return PrivateKeySet{}, fmt.Errorf("failed to parse JSON from %s: %w", filename, err)
	}

	// Decode X25519 Private Key
	xPriv, err := base64.StdEncoding.DecodeString(base64Keys.DecryptionKey)
	if err != nil {
		return PrivateKeySet{}, fmt.Errorf("failed to decode X25519 private key: %w", err)
	}
	if len(xPriv) != 32 {
		return PrivateKeySet{}, fmt.Errorf("invalid X25519 private key size: expected 32 bytes, got %d", len(xPriv))
	}

	// Decode Ed25519 Private Key
	edPriv, err := base64.StdEncoding.DecodeString(base64Keys.SigningKey)
	if err != nil {
		return PrivateKeySet{}, fmt.Errorf("failed to decode Ed25519 private key: %w", err)
	}
	if len(edPriv) != ed25519.PrivateKeySize {
		return PrivateKeySet{}, fmt.Errorf("invalid Ed25519 private key size: expected %d bytes, got %d", ed25519.PrivateKeySize, len(edPriv))
	}

	return PrivateKeySet{
		DecryptionKey: xPriv,
		SigningKey:    ed25519.PrivateKey(edPriv),
	}, nil
}

// Ed25519PrivateKeyToCurve25519 converts an Ed25519 private key to an X25519 private key.
func Ed25519PrivateKeyToCurve25519(edPriv ed25519.PrivateKey) []byte {
	var curvePriv [32]byte
	copy(curvePriv[:], edPriv[:32])
	return curvePriv[:]
}

// DeriveX25519PublicKey calculates the X25519 public key from the Ed25519 private key.
func DeriveX25519PublicKey(edPriv ed25519.PrivateKey) ([]byte, error) {
	x25519Priv := Ed25519PrivateKeyToCurve25519(edPriv)
	x25519Pub, err := curve25519.X25519(x25519Priv, curve25519.Basepoint)
	if err != nil {
		return nil, err
	}
	return x25519Pub, nil
}

// keyDerivationFunction uses HKDF to derive a Key Encryption Key (KEK).
func keyDerivationFunction(sharedSecret []byte, keyLen int) ([]byte, error) {
	kekInfo := []byte("HPKE_KEK_Wrap")
	h := hkdf.New(sha256.New, sharedSecret, nil, kekInfo)
	key := make([]byte, keyLen)
	if _, err := h.Read(key); err != nil {
		return nil, fmt.Errorf("hkdf read failed: %w", err)
	}
	return key, nil
}

// keyWrap encrypts the symmetric key (chachaKey) using the DH shared secret's HKDF output (KEK).
func keyWrap(sharedSecret, chachaKey []byte) ([]byte, error) {
	kek, err := keyDerivationFunction(sharedSecret, 32)
	if err != nil {
		return nil, err
	}

	aead, err := chacha20poly1305.New(kek)
	if err != nil {
		return nil, fmt.Errorf("failed to create AEAD for key wrap: %w", err)
	}

	nonce := make([]byte, aead.NonceSize())
	wrappedKey := aead.Seal(nil, nonce, chachaKey, nil)
	return wrappedKey, nil
}

// keyUnwrap decrypts the symmetric key (chachaKey) using the DH shared secret's HKDF output (KEK).
func keyUnwrap(sharedSecret, wrappedKey []byte) ([]byte, error) {
	kek, err := keyDerivationFunction(sharedSecret, 32)
	if err != nil {
		return nil, err
	}

	aead, err := chacha20poly1305.New(kek)
	if err != nil {
		return nil, fmt.Errorf("failed to create AEAD for key unwrap: %w", err)
	}

	nonce := make([]byte, aead.NonceSize())

	chachaKey, err := aead.Open(nil, nonce, wrappedKey, nil)
	if err != nil {
		return nil, errors.New("key unwrap failed (invalid tag)")
	}
	return chachaKey, nil
}

// CreateNormalizedMessage generates a deterministic string from the message components for signing.
func CreateNormalizedMessage(msg EncryptedMessage) []byte {
	versionHex := fmt.Sprintf("%02x", msg.Version)
	wrappedKeysJoined := strings.Join(msg.WrappedKeys, "")

	senderKeys := append(msg.Sender.EncryptionKey, msg.Sender.SignatureKey...)
	senderKeysBase64 := base64.StdEncoding.EncodeToString(senderKeys)

	dataBase64 := msg.Data

	normalizedString := versionHex + wrappedKeysJoined + senderKeysBase64 + dataBase64

	return []byte(normalizedString)
}

// GenerateKeys generates a pair of Ed25519 public/private keys.
func GenerateKeys() (ed25519.PublicKey, ed25519.PrivateKey, error) {
	return ed25519.GenerateKey(rand.Reader)
}

// GenerateKeySets generates a complete set of X25519 and Ed25519 key pairs.
// It returns the public keys in the Base64-string structure for file output
// and the private keys in the binary structure for immediate use.
func GenerateKeySets() (PublicKeySet, PrivateKeySet, error) {
	// 1. Generate core Ed25519 key pair
	edPub, edPriv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return PublicKeySet{}, PrivateKeySet{}, fmt.Errorf("failed to generate Ed25519 keys: %w", err)
	}

	// 2. Derive X25519 keys from the Ed25519 private key
	x25519Pub, err := DeriveX25519PublicKey(edPriv)
	if err != nil {
		return PublicKeySet{}, PrivateKeySet{}, fmt.Errorf("failed to derive X25519 public key: %w", err)
	}
	x25519Priv := Ed25519PrivateKeyToCurve25519(edPriv)

	// 3. Package Public Keys (Base64 encoded strings for file output)
	pubKeys := PublicKeySet{
		EncryptionKey: base64.StdEncoding.EncodeToString(x25519Pub),
		SignatureKey:  base64.StdEncoding.EncodeToString(edPub),
	}

	// 4. Package Private Keys (Binary format for runtime use)
	privKeys := PrivateKeySet{
		DecryptionKey: x25519Priv,
		SigningKey:    edPriv,
	}

	return pubKeys, privKeys, nil
}

func (pks *PublicKeySet) Base64EncryptionKey() (string, error) {
	return pks.EncryptionKey, nil
}

func (pks *PublicKeySet) Base64SignatureKey() (string, error) {
	return pks.SignatureKey, nil
}

func (pks *PublicKeySet) BinaryEncryptionKey() ([]byte, error) {
	return base64.StdEncoding.DecodeString(pks.EncryptionKey)
}

func (pks *PublicKeySet) BinarySignatureKey() ([]byte, error) {
	return base64.StdEncoding.DecodeString(pks.SignatureKey)
}

func CreateMessageContact(endpoint string, pk PublicKeySet) (*MessageContact, error) {
	ek, err := pk.BinaryEncryptionKey()
	if err != nil {
		return nil, err
	}
	sk, err := pk.BinarySignatureKey()
	if err != nil {
		return nil, err
	}
	contact := MessageContact{
		Endpoint:      endpoint,
		SignatureKey:  sk,
		EncryptionKey: ek,
	}
	return &contact, nil
}
